From d7625b0ddb5c3477fb556deb8a6717b2533c5c97 Mon Sep 17 00:00:00 2001
From: Komari Spaghetti <3759175+Hejsil@users.noreply.github.com>
Date: Mon, 14 Jun 2021 09:48:06 +0200
Subject: [PATCH] Add the ability to have any tag in matroska

---
 gst/matroska/matroska-ids.h         |   2 +
 gst/matroska/matroska-mux.c         | 116 ++++++++++++++--------------
 gst/matroska/matroska-read-common.c |  26 ++++++-
 3 files changed, 82 insertions(+), 62 deletions(-)

diff --git a/gst/matroska/matroska-ids.h b/gst/matroska/matroska-ids.h
index 85ed45e82..b2cd6e901 100644
--- a/gst/matroska/matroska-ids.h
+++ b/gst/matroska/matroska-ids.h
@@ -469,6 +469,8 @@
 #define GST_MATROSKA_TAG_ID_PRODUCTION_COPYRIGHT "PRODUCTION_COPYRIGHT"
 #define GST_MATROSKA_TAG_ID_LICENSE "LICENSE"
 
+#define GST_MATROSKA_TAG_ID_GST_TAG    "GSTREAMER_TAG"
+
 /*
  * TODO: add this tag & mappings
  * "REPLAYGAIN_GAIN" -> GST_TAG_*_GAIN   see http://replaygain.hydrogenaudio.org/rg_data_format.html
diff --git a/gst/matroska/matroska-mux.c b/gst/matroska/matroska-mux.c
index 50adc5758..8e3c14722 100644
--- a/gst/matroska/matroska-mux.c
+++ b/gst/matroska/matroska-mux.c
@@ -3013,6 +3013,9 @@ gst_matroska_mux_start (GstMatroskaMux * mux, GstMatroskaPad * first_pad,
   gint64 time;
   gchar s_id[32];
   GstToc *toc;
+  const GstTagList *tags;
+  gboolean has_main_tags;
+
 
   /* if not streaming, check if downstream is seekable */
   if (!mux->ebml_write->streamable) {
@@ -3078,29 +3081,24 @@ gst_matroska_mux_start (GstMatroskaMux * mux, GstMatroskaPad * first_pad,
     gst_ebml_write_master_finish (ebml, master);
   }
 
-  if (mux->ebml_write->streamable) {
-    const GstTagList *tags;
-    gboolean has_main_tags;
-
-    /* tags */
-    tags = gst_tag_setter_get_tag_list (GST_TAG_SETTER (mux));
-    has_main_tags = tags != NULL && !gst_matroska_mux_tag_list_is_empty (tags);
+  /* tags */
+  tags = gst_tag_setter_get_tag_list (GST_TAG_SETTER (mux));
+  has_main_tags = tags != NULL && !gst_matroska_mux_tag_list_is_empty (tags);
 
-    if (has_main_tags || gst_matroska_mux_streams_have_tags (mux)) {
-      guint64 master_tags, master_tag;
+  if (has_main_tags || gst_matroska_mux_streams_have_tags (mux)) {
+    guint64 master_tags, master_tag;
 
-      GST_DEBUG_OBJECT (mux, "Writing tags");
+    GST_DEBUG_OBJECT (mux, "Writing tags");
 
-      mux->tags_pos = ebml->pos;
-      master_tags = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAGS);
-      if (has_main_tags) {
-        master_tag = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAG);
-        gst_tag_list_foreach (tags, gst_matroska_mux_write_simple_tag, ebml);
-        gst_ebml_write_master_finish (ebml, master_tag);
-      }
-      gst_matroska_mux_write_streams_tags (mux);
-      gst_ebml_write_master_finish (ebml, master_tags);
+    mux->tags_pos = ebml->pos;
+    master_tags = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAGS);
+    if (has_main_tags) {
+      master_tag = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAG);
+      gst_tag_list_foreach (tags, gst_matroska_mux_write_simple_tag, ebml);
+      gst_ebml_write_master_finish (ebml, master_tag);
     }
+    gst_matroska_mux_write_streams_tags (mux);
+    gst_ebml_write_master_finish (ebml, master_tags);
   }
 
   /* segment info */
@@ -3322,23 +3320,17 @@ gst_matroska_mux_tag_list_is_empty (const GstTagList * list)
   int i;
   for (i = 0; i < gst_tag_list_n_tags (list); i++) {
     const gchar *tag = gst_tag_list_nth_tag_name (list, i);
-    int i;
-    for (i = 0; i < G_N_ELEMENTS (gst_matroska_tag_conv); i++) {
-      const gchar *tagname_gst = gst_matroska_tag_conv[i].gstreamer_tagname;
-      if (strcmp (tagname_gst, tag) == 0) {
-        GValue src = { 0, };
-        gchar *dest;
-
-        if (!gst_tag_list_copy_value (&src, list, tag))
-          break;
-        dest = gst_value_serialize (&src);
+    GValue src = { 0, };
+    gchar *dest;
 
-        g_value_unset (&src);
-        if (dest) {
-          g_free (dest);
-          return FALSE;
-        }
-      }
+    if (!gst_tag_list_copy_value (&src, list, tag))
+      break;
+    dest = gst_value_serialize (&src);
+
+    g_value_unset (&src);
+    if (dest) {
+      g_free (dest);
+      return FALSE;
     }
   }
   return TRUE;
@@ -3351,32 +3343,44 @@ gst_matroska_mux_write_simple_tag (const GstTagList * list, const gchar * tag,
   GstEbmlWrite *ebml = (GstEbmlWrite *) data;
   guint i;
   guint64 simpletag_master;
+  GValue src = { 0, };
+  gchar *dest, *formatted;
+
+
+  if (!gst_tag_list_copy_value (&src, list, tag))
+   return;
+  if (!(dest = gst_value_serialize (&src))) {
+    GST_WARNING ("Can't transform tag '%s' to string", tag);
+    g_value_unset (&src);
+    return;
+  }
 
   for (i = 0; i < G_N_ELEMENTS (gst_matroska_tag_conv); i++) {
     const gchar *tagname_gst = gst_matroska_tag_conv[i].gstreamer_tagname;
     const gchar *tagname_mkv = gst_matroska_tag_conv[i].matroska_tagname;
 
     if (strcmp (tagname_gst, tag) == 0) {
-      GValue src = { 0, };
-      gchar *dest;
-
-      if (!gst_tag_list_copy_value (&src, list, tag))
-        break;
-      if ((dest = gst_value_serialize (&src))) {
-
-        simpletag_master = gst_ebml_write_master_start (ebml,
-            GST_MATROSKA_ID_SIMPLETAG);
-        gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME, tagname_mkv);
-        gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, dest);
-        gst_ebml_write_master_finish (ebml, simpletag_master);
-        g_free (dest);
-      } else {
-        GST_WARNING ("Can't transform tag '%s' to string", tagname_mkv);
-      }
+      simpletag_master = gst_ebml_write_master_start (ebml,
+          GST_MATROSKA_ID_SIMPLETAG);
+      gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME, tagname_mkv);
+      gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, dest);
+      gst_ebml_write_master_finish (ebml, simpletag_master);
+      g_free (dest);
       g_value_unset (&src);
-      break;
+      return;
     }
   }
+
+  formatted = g_strdup_printf("%s@%s", tag, dest);
+  simpletag_master = gst_ebml_write_master_start (ebml,
+      GST_MATROSKA_ID_SIMPLETAG);
+  gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME,
+      GST_MATROSKA_TAG_ID_GST_TAG);
+  gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, formatted);
+  gst_ebml_write_master_finish (ebml, simpletag_master);
+  g_free(formatted);
+  g_free (dest);
+  g_value_unset (&src);
 }
 
 static void
@@ -3541,8 +3545,6 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
       master_tags = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAGS);
       master_tag = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAG);
 
-      if (tags != NULL)
-        gst_tag_list_foreach (tags, gst_matroska_mux_write_simple_tag, ebml);
       if (mux->internal_toc != NULL) {
         toc_tags = gst_toc_get_tags (mux->internal_toc);
         toc_has_tags = (toc_tags != NULL);
@@ -3561,12 +3563,6 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
       }
     }
 
-    if (master_tags == 0 && gst_matroska_mux_streams_have_tags (mux)) {
-      mux->tags_pos = ebml->pos;
-      master_tags = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TAGS);
-    }
-    gst_matroska_mux_write_streams_tags (mux);
-
     if (master_tags != 0)
       gst_ebml_write_master_finish (ebml, master_tags);
   }
diff --git a/gst/matroska/matroska-read-common.c b/gst/matroska/matroska-read-common.c
index 90d6e38e1..c03483f71 100644
--- a/gst/matroska/matroska-read-common.c
+++ b/gst/matroska/matroska-read-common.c
@@ -2300,7 +2300,6 @@ gst_matroska_read_common_parse_metadata_id_simple_tag (GstMatroskaReadCommon *
 
     for (i = 0; !matched && i < G_N_ELEMENTS (tag_conv); i++) {
       const gchar *tagname_gst = tag_conv[i].gstreamer_tagname;
-
       const gchar *tagname_mkv = tag_conv[i].matroska_tagname;
 
       if (strcmp (tagname_mkv, tag) == 0) {
@@ -2332,7 +2331,30 @@ gst_matroska_read_common_parse_metadata_id_simple_tag (GstMatroskaReadCommon *
         matched = TRUE;
       }
     }
-    if (!matched) {
+    if (!matched && strcmp (GST_MATROSKA_TAG_ID_GST_TAG, tag) == 0 ) {
+      gchar **tokenized = g_strsplit(value, "@", 2);
+      gchar *tagname_gst, *value_gst;
+
+      if ((tagname_gst = tokenized[0]) && (value_gst = tokenized[1])) {
+        GValue dest = { 0, };
+        GType dest_type = gst_tag_get_type (tagname_gst);
+        g_value_init (&dest, dest_type);
+
+        if (gst_value_deserialize (&dest, value_gst)) {
+          gst_tag_list_add_values (*p_taglist, GST_TAG_MERGE_APPEND,
+              tagname_gst, &dest, NULL);
+        } else {
+          GST_WARNING_OBJECT (common->sinkpad, "Can't transform tag '%s' with "
+              "value '%s' to target type '%s'", tagname_gst, value_gst,
+              g_type_name (dest_type));
+        }
+        g_value_unset (&dest);
+      } else {
+          GST_WARNING_OBJECT (common->sinkpad, "Invalid GST_TAG format '%s'", value);
+      }
+
+      g_strfreev(tokenized);
+    } else if (!matched) {
       gchar *key_val;
       /* TODO: read LANGUAGE sub-tag, and use "key[lc]=val" form */
       key_val = g_strdup_printf ("%s=%s", tag, value);
-- 
2.32.0

