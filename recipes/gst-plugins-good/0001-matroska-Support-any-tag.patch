From 7e32c86b039ffcf3b5ee8a03644912c44be40563 Mon Sep 17 00:00:00 2001
From: Komari Spaghetti <3759175+Hejsil@users.noreply.github.com>
Date: Tue, 13 Jul 2021 11:28:24 +0000
Subject: [PATCH] Add the ability to have any tag in matroska

---
 gst/matroska/matroska-ids.h         |  1 +
 gst/matroska/matroska-mux.c         | 74 ++++++++++++++++-------------
 gst/matroska/matroska-read-common.c | 29 ++++++++++-
 3 files changed, 69 insertions(+), 35 deletions(-)

diff --git a/gst/matroska/matroska-ids.h b/gst/matroska/matroska-ids.h
index 8d4a685a9..cac097c9e 100644
--- a/gst/matroska/matroska-ids.h
+++ b/gst/matroska/matroska-ids.h
@@ -465,6 +465,7 @@
 #define GST_MATROSKA_TAG_ID_RECORDING_LOCATION "RECORDING_LOCATION"
 #define GST_MATROSKA_TAG_ID_PRODUCTION_COPYRIGHT "PRODUCTION_COPYRIGHT"
 #define GST_MATROSKA_TAG_ID_LICENSE "LICENSE"
+#define GST_MATROSKA_TAG_ID_GST_TAG "GSTREAMER_TAG"
 
 /*
  * TODO: add this tag & mappings
diff --git a/gst/matroska/matroska-mux.c b/gst/matroska/matroska-mux.c
index 3cb9bae68..1a32d348d 100644
--- a/gst/matroska/matroska-mux.c
+++ b/gst/matroska/matroska-mux.c
@@ -3303,23 +3303,17 @@ gst_matroska_mux_tag_list_is_empty (const GstTagList * list)
   int i;
   for (i = 0; i < gst_tag_list_n_tags (list); i++) {
     const gchar *tag = gst_tag_list_nth_tag_name (list, i);
-    int i;
-    for (i = 0; i < G_N_ELEMENTS (gst_matroska_tag_conv); i++) {
-      const gchar *tagname_gst = gst_matroska_tag_conv[i].gstreamer_tagname;
-      if (strcmp (tagname_gst, tag) == 0) {
-        GValue src = { 0, };
-        gchar *dest;
-
-        if (!gst_tag_list_copy_value (&src, list, tag))
-          break;
-        dest = gst_value_serialize (&src);
+    GValue src = { 0, };
+    gchar *dest;
 
-        g_value_unset (&src);
-        if (dest) {
-          g_free (dest);
-          return FALSE;
-        }
-      }
+    if (!gst_tag_list_copy_value (&src, list, tag))
+      break;
+    dest = gst_value_serialize (&src);
+
+    g_value_unset (&src);
+    if (dest) {
+      g_free (dest);
+      return FALSE;
     }
   }
   return TRUE;
@@ -3332,32 +3326,44 @@ gst_matroska_mux_write_simple_tag (const GstTagList * list, const gchar * tag,
   GstEbmlWrite *ebml = (GstEbmlWrite *) data;
   guint i;
   guint64 simpletag_master;
+  GValue src = { 0, };
+  gchar *dest, *formatted;
+
+
+  if (!gst_tag_list_copy_value (&src, list, tag))
+   return;
+  if (!(dest = gst_value_serialize (&src))) {
+    GST_WARNING ("Can't transform tag '%s' to string", tag);
+    g_value_unset (&src);
+    return;
+  }
 
   for (i = 0; i < G_N_ELEMENTS (gst_matroska_tag_conv); i++) {
     const gchar *tagname_gst = gst_matroska_tag_conv[i].gstreamer_tagname;
     const gchar *tagname_mkv = gst_matroska_tag_conv[i].matroska_tagname;
 
     if (strcmp (tagname_gst, tag) == 0) {
-      GValue src = { 0, };
-      gchar *dest;
-
-      if (!gst_tag_list_copy_value (&src, list, tag))
-        break;
-      if ((dest = gst_value_serialize (&src))) {
-
-        simpletag_master = gst_ebml_write_master_start (ebml,
-            GST_MATROSKA_ID_SIMPLETAG);
-        gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME, tagname_mkv);
-        gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, dest);
-        gst_ebml_write_master_finish (ebml, simpletag_master);
-        g_free (dest);
-      } else {
-        GST_WARNING ("Can't transform tag '%s' to string", tagname_mkv);
-      }
+      simpletag_master = gst_ebml_write_master_start (ebml,
+          GST_MATROSKA_ID_SIMPLETAG);
+      gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME, tagname_mkv);
+      gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, dest);
+      gst_ebml_write_master_finish (ebml, simpletag_master);
+      g_free (dest);
       g_value_unset (&src);
-      break;
+      return;
     }
   }
+
+  formatted = g_strdup_printf("%s@%s", tag, dest);
+  simpletag_master = gst_ebml_write_master_start (ebml,
+      GST_MATROSKA_ID_SIMPLETAG);
+  gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_TAGNAME,
+      GST_MATROSKA_TAG_ID_GST_TAG);
+  gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TAGSTRING, formatted);
+  gst_ebml_write_master_finish (ebml, simpletag_master);
+  g_free(formatted);
+  g_free (dest);
+  g_value_unset (&src);
 }
 
 static void
@@ -3589,7 +3595,7 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
     gst_ebml_write_seek (ebml, my_pos);
   }
 
-  if (tags != NULL || toc_has_tags) {
+  if (mux->tags_pos != 0 || toc_has_tags) {
     gst_ebml_replace_uint (ebml, mux->seekhead_pos + 144,
         mux->tags_pos - mux->segment_master);
   } else {
diff --git a/gst/matroska/matroska-read-common.c b/gst/matroska/matroska-read-common.c
index 90d6e38e1..3e8b8cc35 100644
--- a/gst/matroska/matroska-read-common.c
+++ b/gst/matroska/matroska-read-common.c
@@ -2300,7 +2300,6 @@ gst_matroska_read_common_parse_metadata_id_simple_tag (GstMatroskaReadCommon *
 
     for (i = 0; !matched && i < G_N_ELEMENTS (tag_conv); i++) {
       const gchar *tagname_gst = tag_conv[i].gstreamer_tagname;
-
       const gchar *tagname_mkv = tag_conv[i].matroska_tagname;
 
       if (strcmp (tagname_mkv, tag) == 0) {
@@ -2332,6 +2331,34 @@ gst_matroska_read_common_parse_metadata_id_simple_tag (GstMatroskaReadCommon *
         matched = TRUE;
       }
     }
+
+    if (!matched && strcmp (GST_MATROSKA_TAG_ID_GST_TAG, tag) == 0 ) {
+      gchar **tokenized = g_strsplit(value, "@", 2);
+      gchar *tagname_gst, *value_gst;
+
+      if ((tagname_gst = tokenized[0]) && (value_gst = tokenized[1]) &&
+          gst_tag_exists (tagname_gst)) {
+        GValue dest = { 0, };
+        GType dest_type = gst_tag_get_type (tagname_gst);
+        g_value_init (&dest, dest_type);
+
+        if (gst_value_deserialize (&dest, value_gst)) {
+          gst_tag_list_add_values (*p_taglist, GST_TAG_MERGE_APPEND,
+              tagname_gst, &dest, NULL);
+          matched = TRUE;
+        } else {
+          GST_WARNING_OBJECT (common->sinkpad, "Can't transform tag '%s' with "
+              "value '%s' to target type '%s'", tagname_gst, value_gst,
+              g_type_name (dest_type));
+        }
+        g_value_unset (&dest);
+      } else {
+          GST_WARNING_OBJECT (common->sinkpad, "Invalid GST_TAG format '%s'", value);
+      }
+
+      g_strfreev(tokenized);
+    }
+
     if (!matched) {
       gchar *key_val;
       /* TODO: read LANGUAGE sub-tag, and use "key[lc]=val" form */
-- 
2.33.0

