diff --git a/src/bootstrap/builder.rs b/src/bootstrap/builder.rs
index 6ccf8b1d522..75aa5dd85c9 100644
--- a/src/bootstrap/builder.rs
+++ b/src/bootstrap/builder.rs
@@ -1432,9 +1432,10 @@ pub fn cargo(
 
             if let Ok(cxx) = self.cxx(target) {
                 let cxx = ccacheify(&cxx);
+                let cxxflags = self.cxxflags(target, GitRepo::Rustc).join(" ");
                 cargo
                     .env(format!("CXX_{}", target.triple), &cxx)
-                    .env(format!("CXXFLAGS_{}", target.triple), cflags);
+                    .env(format!("CXXFLAGS_{}", target.triple), cxxflags);
             }
         }
 
diff --git a/src/bootstrap/lib.rs b/src/bootstrap/lib.rs
index 8569089f701..b3ad95f7e36 100644
--- a/src/bootstrap/lib.rs
+++ b/src/bootstrap/lib.rs
@@ -979,6 +979,44 @@ fn cflags(&self, target: TargetSelection, which: GitRepo) -> Vec<String> {
         base
     }
 
+    fn cxxflags(&self, target: TargetSelection, which: GitRepo) -> Vec<String> {
+        // Filter out -O and /O (the optimization flags) that we picked up from
+        // cc-rs because the build scripts will determine that for themselves.
+        let mut base = self.cxx[&target]
+            .args()
+            .iter()
+            .map(|s| s.to_string_lossy().into_owned())
+            .filter(|s| !s.starts_with("-O") && !s.starts_with("/O"))
+            .collect::<Vec<String>>();
+
+        // If we're compiling on macOS then we add a few unconditional flags
+        // indicating that we want libc++ (more filled out than libstdc++) and
+        // we want to compile for 10.7. This way we can ensure that
+        // LLVM/etc are all properly compiled.
+        if target.contains("apple-darwin") {
+            base.push("-stdlib=libc++".into());
+        }
+
+        // Work around an apparently bad MinGW / GCC optimization,
+        // See: https://lists.llvm.org/pipermail/cfe-dev/2016-December/051980.html
+        // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78936
+        if &*target.triple == "i686-pc-windows-gnu" {
+            base.push("-fno-omit-frame-pointer".into());
+        }
+
+        if let Some(map_to) = self.debuginfo_map_to(which) {
+            let map = format!("{}={}", self.src.display(), map_to);
+            let cc = self.cc(target);
+            if cc.ends_with("clang") || cc.ends_with("gcc") {
+                base.push(format!("-fdebug-prefix-map={}", map));
+            } else if cc.ends_with("clang-cl.exe") {
+                base.push("-Xclang".into());
+                base.push(format!("-fdebug-prefix-map={}", map));
+            }
+        }
+        base
+    }
+
     /// Returns the path to the `ar` archive utility for the target specified.
     fn ar(&self, target: TargetSelection) -> Option<&Path> {
         self.ar.get(&target).map(|p| &**p)
